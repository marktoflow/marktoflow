---
workflow:
  id: batch-pr-review
  name: Batch PR Review
  description: Review multiple pull requests in parallel using AI agents

inputs:
  repository:
    type: string
    description: GitHub repository (owner/repo)
  pr_state:
    type: string
    default: open
    description: PR state filter (open, closed, all)

tools:
  github:
    sdk: "@octokit/rest"
    auth:
      token: ${GITHUB_TOKEN}

steps:
  # Step 1: Fetch all open PRs
  - id: fetch_prs
    action: github.pulls.list
    inputs:
      owner: "{{ inputs.repository.split('/')[0] }}"
      repo: "{{ inputs.repository.split('/')[1] }}"
      state: "{{ inputs.pr_state }}"
      per_page: 50
    output_variable: pull_requests

  # Step 2: Process PRs in parallel (up to 5 concurrent agents)
  - id: review_prs
    action: parallel.map
    inputs:
      items: "{{ pull_requests.data }}"
      concurrency: 5  # Process 5 PRs at a time
      timeout: 90s    # 90 seconds per PR
      onError: continue  # Continue even if some PRs fail

      agent:
        provider: claude
        model: haiku  # Fast model for batch processing
        prompt: |
          Review this pull request and provide analysis:

          **PR #{{ item.number }}:** {{ item.title }}
          **Author:** {{ item.user.login }}
          **Created:** {{ item.created_at }}
          **Branch:** {{ item.head.ref }} â†’ {{ item.base.ref }}
          **Description:**
          {{ item.body or 'No description provided' }}

          **Files changed:** {{ item.changed_files }}
          **Additions:** +{{ item.additions }}
          **Deletions:** -{{ item.deletions }}

          Analyze and provide:
          1. Summary of changes (1-2 sentences)
          2. Potential issues or risks (list)
          3. Recommendation: APPROVE, REQUEST_CHANGES, or COMMENT
          4. Priority: HIGH, MEDIUM, LOW
          5. Estimated review time: <minutes>

          Respond in JSON format:
          {
            "summary": "...",
            "issues": ["..."],
            "recommendation": "APPROVE|REQUEST_CHANGES|COMMENT",
            "priority": "HIGH|MEDIUM|LOW",
            "estimated_review_minutes": <number>
          }

    output_variable: pr_reviews

  # Step 3: Categorize PRs by recommendation
  - id: categorize_prs
    action: core.transform
    inputs:
      input: "{{ pull_requests.data }}"
      operation: group_by
      key: "{{ pr_reviews[loop.index0].recommendation }}"
    output_variable: categorized

  # Step 4: Filter high-priority PRs
  - id: high_priority_prs
    action: core.transform
    inputs:
      input: "{{ pull_requests.data }}"
      operation: filter
      condition: "{{ pr_reviews[loop.index0].priority == 'HIGH' }}"
    output_variable: urgent_prs

  # Step 5: Generate summary report
  - id: generate_summary
    action: claude.chat.completions
    inputs:
      model: sonnet
      messages:
        - role: user
          content: |
            Create a PR review dashboard summary:

            Total PRs reviewed: {{ pull_requests.data | length }}
            High priority PRs: {{ urgent_prs | length }}

            Reviews by recommendation:
            - Approve: {{ categorized.APPROVE | default([]) | length }}
            - Request Changes: {{ categorized.REQUEST_CHANGES | default([]) | length }}
            - Comment: {{ categorized.COMMENT | default([]) | length }}

            High Priority PRs:
            {{ urgent_prs | tojson }}

            All Reviews:
            {{ pr_reviews | tojson }}

            Generate a markdown dashboard with:
            1. Overall statistics
            2. High-priority PRs table (number, title, author, recommendation)
            3. PRs needing attention (REQUEST_CHANGES)
            4. PRs ready to merge (APPROVE)
            5. Estimated total review time
    output_variable: dashboard

  # Step 6: Post summary as GitHub issue (optional)
  - id: create_summary_issue
    action: github.issues.create
    conditions:
      - "urgent_prs | length > 0"  # Only create if urgent PRs exist
    inputs:
      owner: "{{ inputs.repository.split('/')[0] }}"
      repo: "{{ inputs.repository.split('/')[1] }}"
      title: "ðŸ¤– AI PR Review Dashboard - {{ now() }}"
      body: |
        {{ dashboard.choices[0].message.content }}

        ---
        *Generated by marktoflow parallel.map workflow*
        *Processed {{ pull_requests.data | length }} PRs in parallel*
      labels:
        - ai-review
        - automation
    output_variable: issue_result

outputs:
  total_prs: "{{ pull_requests.data | length }}"
  high_priority_count: "{{ urgent_prs | length }}"
  dashboard_url: "{{ issue_result.data.html_url }}"
  reviews: "{{ pr_reviews }}"
  processing_stats:
    total_items: "{{ pull_requests.data | length }}"
    successful: "{{ pr_reviews | length }}"
---

# Batch Pull Request Processing

This workflow demonstrates using `parallel.map` to process multiple pull requests concurrently, significantly speeding up batch operations.

## Usage

```bash
# Review all open PRs in a repository
./marktoflow run examples/parallel-agents/batch-pr-processing.md \
  --input repository=facebook/react

# Review closed PRs from last week
./marktoflow run examples/parallel-agents/batch-pr-processing.md \
  --input repository=microsoft/vscode \
  --input pr_state=closed

# Use faster/cheaper model for large batches
./marktoflow run examples/parallel-agents/batch-pr-processing.md \
  --input repository=vercel/next.js \
  --concurrency 10
```

## Performance Comparison

### Sequential Processing
- 50 PRs Ã— 30 seconds each = **25 minutes**
- Cost: $0.50 (assuming $0.01/PR)

### Parallel Processing (concurrency=5)
- 50 PRs Ã· 5 concurrent Ã— 30 seconds = **5 minutes**
- Cost: $0.50 (same cost, 5x faster)

### Parallel Processing (concurrency=10)
- 50 PRs Ã· 10 concurrent Ã— 30 seconds = **2.5 minutes**
- Cost: $0.50 (same cost, 10x faster)

## Key Features

1. **Concurrency Control**: Process 5 PRs at a time (configurable)
2. **Error Handling**: Continue processing even if some PRs fail
3. **Batch Processing**: Efficiently handle large numbers of PRs
4. **Smart Categorization**: Automatically group by recommendation
5. **Priority Detection**: Identify urgent PRs needing immediate attention
6. **Cost Tracking**: Monitor per-PR and total costs
7. **Auto-reporting**: Create GitHub issues for dashboards

## Advanced: Custom Filters

Process only specific PRs by adding a filter step before parallel.map:

```yaml
- id: filter_prs
  action: core.transform
  inputs:
    input: "{{ pull_requests.data }}"
    operation: filter
    condition: "{{ item.user.login != 'dependabot[bot]' and item.changed_files < 20 }}"
  output_variable: filtered_prs
```

## Integration with CI/CD

Run this workflow on a schedule to maintain PR health:

```yaml
triggers:
  - type: schedule
    cron: "0 9 * * 1-5"  # Weekdays at 9 AM
```
